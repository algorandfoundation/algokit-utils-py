

from dataclasses import is_dataclass
from typing import Any, Literal, TypeVar, overload

{% if needs_algod_helpers %}from base64 import b64encode
from collections.abc import Sequence
{% endif %}{% if client_needs_datetime %}from datetime import datetime
{% endif %}

import httpx
import msgpack

from algokit_common.serde import from_wire, to_wire

from . import models
from .config import ClientConfig
from .exceptions import UnexpectedStatusError
from .types import Headers

ModelT = TypeVar("ModelT")
ListModelT = TypeVar("ListModelT")
PrimitiveT = TypeVar("PrimitiveT")

# Prefixed markers used when converting unhashable msgpack map keys into hashable tuples
_UNHASHABLE_PREFIXES: dict[str, str] = {
    "dict": "__dict_key__",
    "list": "__list_key__",
    "set": "__set_key__",
    "generic": "__unhashable__",
}


class {{ client.class_name }}:
    def __init__(self, config: ClientConfig | None = None, *, http_client: httpx.Client | None = None) -> None:
        self._config = config or ClientConfig()
        self._client = http_client or httpx.Client(
            base_url=self._config.base_url,
            timeout=self._config.timeout,
            verify=self._config.verify,
        )

    def close(self) -> None:
        self._client.close()

{%- for group in client.groups %}
    # {{ group.tag }}
    {%- for operation in group.operations %}
    {% set response = operation.response %}
    {% set request = operation.request_body %}
    {% if response and response.model %}
    {% set return_type = 'models.' + response.model %}
    {% elif response and response.list_model %}
    {% set return_type = 'list[models.' + response.list_model + ']' %}
    {% elif response %}
    {% set return_type = response.type_hint %}
    {% else %}
    {% set return_type = 'None' %}
    {% endif %}
    {% if request is not none and request.model %}
    {% set body_type = 'models.' + request.model %}
    {% elif request is not none and request.list_model %}
    {% set body_type = 'list[models.' + request.list_model + ']' %}
    {% elif request is not none %}
    {% set body_type = request.type_hint %}
    {% endif %}
    {% set kw_required = (operation.query_parameters + operation.header_parameters) | selectattr('required') | list %}
    {% set kw_optional = (operation.query_parameters + operation.header_parameters) | rejectattr('required') | list %}
    {% set has_keyword_only = (operation.format_options is not none) or kw_optional or (request is not none and not request.required) %}
    def {{ operation.name }}(  # noqa: C901, PLR0912, PLR0913
        self,
        {% for param in operation.path_parameters %}{{ param.name }}: {{ param.type_hint }},
        {% endfor %}{% for param in kw_required %}{{ param.name }}: {{ param.type_hint }},
        {% endfor %}{% if request is not none and request.required %}body: {{ body_type }},
        {% endif %}{% if has_keyword_only %}
        *,
        {% if operation.format_options %}
        response_format: Literal[{% for opt in operation.format_options %}{{ '"' ~ opt ~ '"' }}{% if not loop.last %}, {% endif %}{% endfor %}]{% if not operation.format_required %} | None{% endif %}{% if operation.format_required %}{% if operation.format_default %} = {{ '"' ~ operation.format_default ~ '"' }}{% endif %}{% else %}{% if operation.format_default %} = {{ '"' ~ operation.format_default ~ '"' }}{% else %} = None{% endif %}{% endif %},
        {% endif %}{% for param in kw_optional %}
        {{ param.name }}: {{ param.type_hint | optional_hint }}{% if param.default_value %} = {{ param.default_value }}{% else %} = None{% endif %},
        {% endfor %}{% if request is not none and not request.required %}
        body: {{ body_type | optional_hint }} = None,
        {% endif %}{% endif %}
    ) -> {{ return_type }}:
{% set doc = operation.summary or operation.description or operation.operation_id %}{{ doc | docstring(8) }}
        path = "{{ operation.path }}"
        {%- for param in operation.path_parameters %}
        path = path.replace("{{ '{' + param.wire_name + '}' }}", str({{ param.name }}))
        {% endfor %}
        params: dict[str, Any] = {}
        headers: Headers = self._config.resolve_headers()
        {%- for param in operation.query_parameters %}
        if {{ param.name }} is not None:
            params["{{ param.wire_name }}"] = {{ param.name }}
        {% endfor %}
        {%- for param in operation.header_parameters %}
        if {{ param.name }} is not None:
            headers["{{ param.wire_name }}"] = str({{ param.name }})
        {% endfor %}
        {% set default_accept = 'application/json' %}
        {% if response and 'application/json' not in response.media_types and response.media_types %}
        {% set default_accept = response.media_types[0] %}
        {% elif response and 'application/json' in response.media_types %}
        {% set default_accept = 'application/json' %}
        {% endif %}
        accept_value: str | None = None
        {% if request %}
        body_media_types = {{ request.media_types }}
        {% endif %}
        {% if operation.format_options %}
        selected_format = response_format
        {% if operation.format_default %}
        if selected_format is None:
            selected_format = "{{ operation.format_default }}"
        {% endif %}
        if selected_format == "msgpack":
            params["format"] = "msgpack"
            accept_value = "application/msgpack"
            {% if request %}
            if "application/msgpack" in body_media_types:
                body_media_types = ["application/msgpack"]
            {% endif %}
        {% elif operation.format_single %}
        {% if operation.format_single == "msgpack" %}
        params["format"] = "msgpack"
        accept_value = "application/msgpack"
        {% if request %}
        if "application/msgpack" in body_media_types:
            body_media_types = ["application/msgpack"]
        {% endif %}
        {% endif %}
        {% endif %}
        headers.setdefault("accept", accept_value or '{{ default_accept }}')
        request_kwargs: dict[str, Any] = {
            "method": "{{ operation.http_method }}",
            "url": path,
            "params": params,
            "headers": headers,
        }
        {% if request %}
        if body is not None:
            self._assign_body(
                request_kwargs,
                body,
                {{ request | descriptor_literal(16) }},
                body_media_types,
            )
        {% endif %}
        response = self._client.request(**request_kwargs)
        if response.is_success:
            {% if response %}
            {% set decode_args = response | response_decode_arguments(16) %}
            return self._decode_response(
                response{{ decode_args }}
            )
            {% else %}
            return None
            {% endif %}
        raise UnexpectedStatusError(response.status_code, response.text)

    {% endfor %}
{% endfor %}
{% if needs_algod_helpers %}
    def send_raw_transaction(
        self,
        stx_or_stxs: bytes | bytearray | memoryview | Sequence[bytes | bytearray | memoryview],
    ) -> models.PostTransactionsResponse:
        """
        Send a signed transaction or array of signed transactions to the network.
        """

        payload: bytes
        if isinstance(stx_or_stxs, bytes | bytearray | memoryview):
            payload = bytes(stx_or_stxs)
        elif isinstance(stx_or_stxs, Sequence):
            segments: list[bytes] = []
            for value in stx_or_stxs:
                if not isinstance(value, bytes | bytearray | memoryview):
                    raise TypeError("All sequence elements must be bytes-like")
                segments.append(bytes(value))
            payload = b"".join(segments)
        else:
            raise TypeError("stx_or_stxs must be bytes or a sequence of bytes-like values")

        return self._raw_transaction(payload)

    def get_application_box_by_name(
        self,
        application_id: int,
        box_name: bytes | bytearray | memoryview | str,
    ) -> models.Box:
        """
        Given an application ID and box name, return the corresponding box details.
        """

        box_bytes = box_name.encode() if isinstance(box_name, str) else bytes(box_name)
        encoded_name = "b64:" + b64encode(box_bytes).decode("ascii")
        return self._get_application_box_by_name(application_id, name=encoded_name)

    def suggested_params(self) -> models.SuggestedParams:
        """
        Return the common parameters required for assembling a transaction.
        """

        txn_params = self._transaction_params()
        last_round = txn_params.last_round
        return models.SuggestedParams(
            consensus_version=txn_params.consensus_version,
            fee=txn_params.fee,
            genesis_hash=txn_params.genesis_hash,
            genesis_id=txn_params.genesis_id,
            min_fee=txn_params.min_fee,
            flat_fee=False,
            first_valid=last_round,
            last_valid=last_round + 1000,
        )
{% endif %}
    def _assign_body(
        self,
        request_kwargs: dict[str, Any],
        payload: object,
        descriptor: dict[str, object],
        media_types: list[str],
    ) -> None:
        encoded = self._encode_payload(payload, descriptor)
        binary_types = {"application/x-binary", "application/octet-stream"}
        if bool(descriptor.get("is_binary")) or any(mt in binary_types for mt in media_types):
            if encoded is None:
                return
            request_kwargs["content"] = encoded
            if media_types:
                request_kwargs.setdefault("headers", {})["content-type"] = media_types[0]
            else:
                request_kwargs.setdefault("headers", {})["content-type"] = "application/octet-stream"
        elif "application/json" in media_types:
            request_kwargs["json"] = encoded
        elif "application/msgpack" in media_types:
            request_kwargs["content"] = msgpack.packb(encoded, use_bin_type=True)
            request_kwargs.setdefault("headers", {})["content-type"] = "application/msgpack"
        else:
            request_kwargs["json"] = encoded

    def _encode_payload(self, payload: object, descriptor: dict[str, object]) -> object:
        if payload is None:
            return None
        if is_dataclass(payload):
            return to_wire(payload)
        list_model = descriptor.get("list_model")
        if list_model and isinstance(payload, list):
            return [to_wire(item) if is_dataclass(item) else item for item in payload]
        return payload

    @overload
    def _decode_response(
        self,
        response: httpx.Response,
        *,
        model: type[ModelT],
        is_binary: bool = False,
        raw_msgpack: bool = False,
    ) -> ModelT:
        ...

    @overload
    def _decode_response(
        self,
        response: httpx.Response,
        *,
        list_model: type[ListModelT],
        is_binary: bool = False,
        raw_msgpack: bool = False,
    ) -> list[ListModelT]:
        ...

    @overload
    def _decode_response(
        self,
        response: httpx.Response,
        *,
        type_: type[PrimitiveT],
        is_binary: bool = False,
        raw_msgpack: bool = False,
    ) -> PrimitiveT:
        ...

    @overload
    def _decode_response(
        self,
        response: httpx.Response,
        *,
        is_binary: Literal[True],
        raw_msgpack: bool = False,
    ) -> bytes:
        ...

    @overload
    def _decode_response(
        self,
        response: httpx.Response,
        *,
        raw_msgpack: Literal[True],
    ) -> bytes:
        ...

    @overload
    def _decode_response(
        self,
        response: httpx.Response,
        *,
        type_: None = None,
        is_binary: bool = False,
        raw_msgpack: bool = False,
    ) -> object:
        ...

    def _decode_response(
        self,
        response: httpx.Response,
        *,
        model: type[Any] | None = None,
        list_model: type[Any] | None = None,
        type_: type[Any] | None = None,
        is_binary: bool = False,
        raw_msgpack: bool = False,
    ) -> object:
        if is_binary or raw_msgpack:
            return response.content
        content_type = response.headers.get("content-type", "application/json")
        if "msgpack" in content_type:
            # Handle msgpack unpacking with support for unhashable keys
            # Use Unpacker for more control over the unpacking process
            unpacker = msgpack.Unpacker(
                raw=True,
                strict_map_key=False,
                object_pairs_hook=self._msgpack_pairs_hook,
            )
            unpacker.feed(response.content)
            try:
                data = unpacker.unpack()
            except TypeError:
                # If unpacking fails due to unhashable keys, try without the hook
                # and handle in normalization
                unpacker = msgpack.Unpacker(raw=True, strict_map_key=False)
                unpacker.feed(response.content)
                data = unpacker.unpack()
            data = self._normalize_msgpack(data)
        elif content_type.startswith("application/json"):
            data = response.json()
        else:
            data = response.text
        if model is not None:
            return from_wire(model, data)
        if list_model is not None:
            return [from_wire(list_model, item) for item in data]
        if type_ is not None:
            return data
        return data

    def _normalize_msgpack(self, value: object) -> object:  # noqa: C901, PLR0912
        # Handle pairs returned from msgpack_pairs_hook when keys are unhashable
        _pair_length = 2
        if (
            isinstance(value, list)
            and value
            and isinstance(value[0], tuple | list)
            and len(value[0]) == _pair_length
        ):
            # Convert to dict with normalized keys
            pairs_dict: dict[object, object] = {}
            for pair in value:
                if isinstance(pair, tuple | list) and len(pair) == _pair_length:
                    k, v = pair
                    # For unhashable keys (like dict keys), use a tuple representation
                    try:
                        normalized_key = self._coerce_msgpack_key(k)
                        pairs_dict[normalized_key] = self._normalize_msgpack(v)
                    except TypeError:
                        # Key is unhashable - use tuple representation
                        normalized_key = ("__unhashable__", id(k), str(k))
                        pairs_dict[normalized_key] = self._normalize_msgpack(v)
            return pairs_dict
        if isinstance(value, dict):
            # Safely normalize maps: coerce string/bytes keys, but tolerate complex/unhashable keys
            try:
                normalized_dict: dict[object, object] = {}
                for key, item in value.items():
                    normalized_dict[self._coerce_msgpack_key(key)] = self._normalize_msgpack(item)
                return normalized_dict
            except TypeError:
                # Some maps can decode to object/dict keys; keep original keys and
                # only normalize values to avoid "unhashable type: 'dict'" errors.
                for k, item in list(value.items()):
                    value[k] = self._normalize_msgpack(item)
                return value
        if isinstance(value, list):
            return [self._normalize_msgpack(item) for item in value]
        return value

    def _coerce_msgpack_key(self, key: object) -> object:
        if isinstance(key, bytes):
            try:
                return key.decode("utf-8")
            except UnicodeDecodeError:
                return key
        return key

    def _msgpack_pairs_hook(self, pairs: list[tuple[object, object]] | list[list[object]]) -> dict[object, object]:
        # Convert pairs to dict, handling unhashable keys by converting them to hashable tuples
        out: dict[object, object] = {}
        _hashable_type_tuple = (str, int, float, bool, type(None), bytes)

        for k, v in pairs:
            if isinstance(k, dict | list | set):
                # Convert unhashable key to hashable tuple
                hashable_key: tuple[str, object]
                if isinstance(k, dict):
                    try:
                        hashable_key = (_UNHASHABLE_PREFIXES["dict"], tuple(sorted(k.items())))
                    except TypeError:
                        hashable_key = (_UNHASHABLE_PREFIXES["dict"], str(k))
                elif isinstance(k, list):
                    prefix = _UNHASHABLE_PREFIXES["list"]
                    hashable_key = (prefix, tuple(k) if all(isinstance(x, _hashable_type_tuple) for x in k) else str(k))
                else:  # set
                    prefix = _UNHASHABLE_PREFIXES["set"]
                    if all(isinstance(x, _hashable_type_tuple) for x in k):
                        hashable_key = (prefix, tuple(sorted(k)))
                    else:
                        hashable_key = (prefix, str(k))
                out[hashable_key] = v
            else:
                # Key should be hashable, use as-is
                try:
                    out[k] = v
                except TypeError:
                    # Unexpected unhashable type, convert to tuple
                    out[(_UNHASHABLE_PREFIXES["generic"], str(type(k).__name__), str(k))] = v
        return out
