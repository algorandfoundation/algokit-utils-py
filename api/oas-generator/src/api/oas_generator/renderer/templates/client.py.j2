from __future__ import annotations

from dataclasses import is_dataclass
from typing import Any

{% if client_needs_datetime %}from datetime import datetime
{% endif %}

import httpx
import msgpack

from algokit_common.serde import from_wire, to_wire

from . import models
from .config import ClientConfig
from .exceptions import UnexpectedStatusError
from .types import Headers


class {{ client.class_name }}:
    def __init__(self, config: ClientConfig | None = None, *, http_client: httpx.Client | None = None) -> None:
        self._config = config or ClientConfig()
        self._client = http_client or httpx.Client(
            base_url=self._config.base_url,
            timeout=self._config.timeout,
            verify=self._config.verify,
        )

    def close(self) -> None:
        self._client.close()

{%- for group in client.groups %}
    # {{ group.tag }}
    {%- for operation in group.operations %}
    {% set response = operation.response %}
    {% set request = operation.request_body %}
    {% if response and response.model %}
    {% set return_type = 'models.' + response.model %}
    {% elif response and response.list_model %}
    {% set return_type = 'list[models.' + response.list_model + ']' %}
    {% elif response %}
    {% set return_type = response.type_hint %}
    {% else %}
    {% set return_type = 'None' %}
    {% endif %}
    {% if request and request.model %}
    {% set body_type = 'models.' + request.model %}
    {% elif request and request.list_model %}
    {% set body_type = 'list[models.' + request.list_model + ']' %}
    {% elif request %}
    {% set body_type = request.type_hint %}
    {% endif %}
    {% set supports_msgpack = operation.prefer_msgpack_flag or (request and 'application/msgpack' in request.media_types) or (response and 'application/msgpack' in response.media_types) %}
    {% set kw_required = (operation.query_parameters + operation.header_parameters) | selectattr('required') | list %}
    {% set kw_optional = (operation.query_parameters + operation.header_parameters) | rejectattr('required') | list %}
    def {{ operation.name }}(
        self,
        {% for param in operation.path_parameters %}{{ param.name }}: {{ param.type_hint }},
        {% endfor %}{% for param in kw_required %}{{ param.name }}: {{ param.type_hint }},
        {% endfor %}{% if request and request.required %}body: {{ body_type }},
        {% endif %}
        *,
        {% for param in kw_optional %}{{ param.name }}: {{ param.type_hint | optional_hint }}{% if param.default_value %} = {{ param.default_value }}{% else %} = None{% endif %},
        {% endfor %}{% if request and not request.required %}body: {{ body_type | optional_hint }} = None,
        {% endif %}{% if supports_msgpack %}prefer_msgpack: bool = False,
        {% endif %}request_timeout: float | None = None,
    ) -> {{ return_type }}:
{% set doc = operation.summary or operation.description or operation.operation_id %}{{ doc | docstring(8) }}
        path = "{{ operation.path }}"
        {%- for param in operation.path_parameters %}
        path = path.replace("{{ '{' + param.wire_name + '}' }}", str({{ param.name }}))
        {% endfor %}
        params: dict[str, Any] = {}
        headers: Headers = self._config.resolve_headers()
        {%- for param in operation.query_parameters %}
        if {{ param.name }} is not None:
            params["{{ param.wire_name }}"] = {{ param.name }}
        {% endfor %}
        {%- for param in operation.header_parameters %}
        if {{ param.name }} is not None:
            headers["{{ param.wire_name }}"] = str({{ param.name }})
        {% endfor %}
        {% if operation.force_msgpack_query %}
        params["format"] = "msgpack"
        {% endif %}
        {% if supports_msgpack %}
        accept = "application/msgpack" if prefer_msgpack else "application/json"
        headers.setdefault("accept", accept)
        {% else %}
        headers.setdefault("accept", "application/json")
        {% endif %}
        request_kwargs: dict[str, Any] = {
            "method": "{{ operation.http_method }}",
            "url": path,
            "params": params,
            "headers": headers,
        }
        {% if request %}
        if body is not None:
            self._assign_body(
                request_kwargs,
                body,
                {{ request | descriptor_literal }},
                {{ request.media_types }},
                prefer_msgpack={% if supports_msgpack %}prefer_msgpack{% else %}False{% endif %},
            )
        {% endif %}
        response = self._client.request(timeout=request_timeout, **request_kwargs)
        if response.is_success:
            {% if response %}return self._decode_response(response, {{ response | descriptor_literal }})
            {% else %}return None
            {% endif %}
        raise UnexpectedStatusError(response.status_code, response.text)

    {% endfor %}
{% endfor %}
    def _assign_body(
        self,
        request_kwargs: dict[str, object],
        payload: object,
        descriptor: dict[str, object],
        media_types: list[str],
        *,
        prefer_msgpack: bool,
    ) -> None:
        encoded = self._encode_payload(payload, descriptor)
        if "application/msgpack" in media_types and prefer_msgpack:
            request_kwargs["content"] = msgpack.packb(encoded, use_bin_type=True)
            request_kwargs["headers"]["content-type"] = "application/msgpack"
        else:
            request_kwargs["json"] = encoded

    def _encode_payload(self, payload: object, descriptor: dict[str, object]) -> object:
        if payload is None:
            return None
        if is_dataclass(payload):
            return to_wire(payload)
        list_model = descriptor.get("list_model")
        if list_model and isinstance(payload, list):
            return [to_wire(item) if is_dataclass(item) else item for item in payload]
        return payload

    def _decode_response(self, response: httpx.Response, descriptor: dict[str, object]) -> object:
        if descriptor.get("is_binary"):
            return response.content
        content_type = response.headers.get("content-type", "application/json")
        if "msgpack" in content_type:
            data = msgpack.unpackb(response.content, raw=False)
        elif content_type.startswith("application/json"):
            data = response.json()
        else:
            data = response.text
        model_name = descriptor.get("model")
        list_model = descriptor.get("list_model")
        if model_name:
            model_cls = getattr(models, model_name)
            return from_wire(model_cls, data)
        if list_model:
            model_cls = getattr(models, list_model)
            return [from_wire(model_cls, item) for item in data]
        return data
