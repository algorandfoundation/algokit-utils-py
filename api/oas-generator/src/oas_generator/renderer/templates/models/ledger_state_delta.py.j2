# AUTO-GENERATED: oas_generator

from collections.abc import Mapping
from dataclasses import dataclass, field
from typing import Callable, TypeVar, cast

from algokit_common.serde import DecodeError, addr, flatten, from_wire, nested, to_wire, wire

from ._serde_helpers import (
    decode_bytes_base64,
    decode_model_mapping,
    decode_model_sequence,
    encode_bytes_base64,
    encode_model_mapping,
    encode_model_sequence,
)
from ._block import Block

DecodedT = TypeVar("DecodedT")

__all__ = [
    "LedgerTealValue",
    "LedgerStateSchema",
    "LedgerAppParams",
    "LedgerAppLocalState",
    "LedgerAppLocalStateDelta",
    "LedgerAppParamsDelta",
    "LedgerAppResourceRecord",
    "LedgerAssetHolding",
    "LedgerAssetHoldingDelta",
    "LedgerAssetParams",
    "LedgerAssetParamsDelta",
    "LedgerAssetResourceRecord",
    "LedgerVotingData",
    "LedgerAccountBaseData",
    "LedgerAccountData",
    "LedgerBalanceRecord",
    "LedgerAccountDeltas",
    "LedgerKvValueDelta",
    "LedgerIncludedTransactions",
    "LedgerModifiedCreatable",
    "LedgerAlgoCount",
    "LedgerAccountTotals",
    "LedgerStateDelta",
]


def _encode_bytes_key(key: object) -> str:
    if isinstance(key, bytes | bytearray | memoryview):
        return encode_bytes_base64(key)
    if isinstance(key, str):
        return key
    raise TypeError("Ledger delta map keys must be bytes-like or str")


def _decode_bytes_key(key: object) -> bytes:
    if isinstance(key, bytes):
        return key
    if isinstance(key, str):
        try:
            return decode_bytes_base64(key)
        except (TypeError, ValueError):
            pass
        return key.encode("utf-8")
    raise TypeError("Ledger delta map keys must be bytes-like or str")


def _encode_teal_value_map(mapping: Mapping[bytes, "LedgerTealValue"] | None) -> dict[str, object] | None:
    if not mapping:
        return None
    return encode_model_mapping(
        lambda: LedgerTealValue,
        cast(Mapping[object, object], mapping),
        key_encoder=_encode_bytes_key,
    )


def _decode_teal_value_map(raw: object) -> dict[bytes, "LedgerTealValue"] | None:
    decoded = decode_model_mapping(lambda: LedgerTealValue, raw, key_decoder=_decode_bytes_key)
    return decoded or None


def _encode_kv_delta_map(mapping: Mapping[bytes, "LedgerKvValueDelta"] | None) -> dict[str, object] | None:
    if not mapping:
        return None
    return encode_model_mapping(
        lambda: LedgerKvValueDelta,
        cast(Mapping[object, object], mapping),
        key_encoder=_encode_bytes_key,
    )


def _decode_kv_delta_map(raw: object) -> dict[bytes, "LedgerKvValueDelta"] | None:
    decoded = decode_model_mapping(lambda: LedgerKvValueDelta, raw, key_decoder=_decode_bytes_key)
    return decoded or None


def _encode_txid_map(mapping: Mapping[bytes, "LedgerIncludedTransactions"] | None) -> dict[str, object] | None:
    if not mapping:
        return None
    return encode_model_mapping(
        lambda: LedgerIncludedTransactions,
        cast(Mapping[object, object], mapping),
        key_encoder=_encode_bytes_key,
    )


def _decode_txid_map(raw: object) -> dict[bytes, "LedgerIncludedTransactions"] | None:
    decoded = decode_model_mapping(lambda: LedgerIncludedTransactions, raw, key_decoder=_decode_bytes_key)
    return decoded or None


def _encode_creatables(mapping: Mapping[int, "LedgerModifiedCreatable | None"] | None) -> dict[int, object] | None:
    if not mapping:
        return None
    encoded: dict[int, object] = {}
    for key, value in mapping.items():
        if value is None:
            continue
        encoded[int(key)] = to_wire(value)
    return encoded or None


def _decode_creatables(raw: object) -> dict[int, "LedgerModifiedCreatable"] | None:
    if not isinstance(raw, Mapping):
        return None
    decoded: dict[int, LedgerModifiedCreatable] = {}
    for key, value in raw.items():
        if not isinstance(value, Mapping):
            continue
        try:
            decoded[int(key)] = from_wire(LedgerModifiedCreatable, value)
        except (DecodeError, TypeError, ValueError):
            continue
    return decoded or None


def _encode_optional_sequence(values: list[object] | None) -> list[dict[str, object]] | None:
    if values is None:
        return None
    encoded = encode_model_sequence(values)
    return encoded or None


def _decode_sequence(factory: Callable[[], type[DecodedT]], raw: object) -> list[DecodedT]:
    decoded = decode_model_sequence(factory, raw)
    return decoded or []


@dataclass(slots=True)
class LedgerTealValue:
    type: int = field(metadata=wire("tt"))
    bytes_: bytes | None = field(
        default=None,
        metadata=wire(
            "tb",
            encode=encode_bytes_base64,
            decode=decode_bytes_base64,
        ),
    )
    uint: int | None = field(default=None, metadata=wire("ui"))


@dataclass(slots=True)
class LedgerStateSchema:
    num_uints: int | None = field(default=None, metadata=wire("nui"))
    num_byte_slices: int | None = field(default=None, metadata=wire("nbs"))


@dataclass(slots=True)
class LedgerAppParams:
    approval_program: bytes = field(
        metadata=wire(
            "approv",
            encode=encode_bytes_base64,
            decode=decode_bytes_base64,
        ),
    )
    clear_state_program: bytes = field(
        metadata=wire(
            "clearp",
            encode=encode_bytes_base64,
            decode=decode_bytes_base64,
        ),
    )
    local_state_schema: LedgerStateSchema = field(metadata=nested("lsch", lambda: LedgerStateSchema))
    global_state_schema: LedgerStateSchema = field(metadata=nested("gsch", lambda: LedgerStateSchema))
    extra_program_pages: int = field(metadata=wire("epp"))
    version: int | None = field(default=None, metadata=wire("v"))
    size_sponsor: str | None = field(
        default=None,
        metadata=addr("ss"),
    )
    global_state: dict[bytes, LedgerTealValue] | None = field(
        default=None,
        metadata=wire(
            "gs",
            encode=_encode_teal_value_map,
            decode=_decode_teal_value_map,
        ),
    )


@dataclass(slots=True)
class LedgerAppLocalState:
    schema: LedgerStateSchema = field(metadata=nested("hsch", lambda: LedgerStateSchema))
    key_value: dict[bytes, LedgerTealValue] | None = field(
        default=None,
        metadata=wire(
            "tkv",
            encode=_encode_teal_value_map,
            decode=_decode_teal_value_map,
        ),
    )


@dataclass(slots=True)
class LedgerAppLocalStateDelta:
    deleted: bool = field(metadata=wire("Deleted"))
    local_state: LedgerAppLocalState | None = field(
        default=None,
        metadata=nested("LocalState", lambda: LedgerAppLocalState),
    )


@dataclass(slots=True)
class LedgerAppParamsDelta:
    deleted: bool = field(metadata=wire("Deleted"))
    params: LedgerAppParams | None = field(
        default=None,
        metadata=nested("Params", lambda: LedgerAppParams),
    )


@dataclass(slots=True)
class LedgerAppResourceRecord:
    app_id: int = field(metadata=wire("Aidx"))
    address: str = field(metadata=addr("Addr"))
    params: LedgerAppParamsDelta = field(metadata=nested("Params", lambda: LedgerAppParamsDelta))
    state: LedgerAppLocalStateDelta = field(
        metadata=nested("State", lambda: LedgerAppLocalStateDelta),
    )


@dataclass(slots=True)
class LedgerAssetHolding:
    amount: int = field(metadata=wire("a"))
    frozen: bool = field(metadata=wire("f"))


@dataclass(slots=True)
class LedgerAssetHoldingDelta:
    deleted: bool = field(metadata=wire("Deleted"))
    holding: LedgerAssetHolding | None = field(
        default=None,
        metadata=nested("Holding", lambda: LedgerAssetHolding),
    )


@dataclass(slots=True)
class LedgerAssetParams:
    total: int = field(metadata=wire("t"))
    decimals: int = field(metadata=wire("dc"))
    default_frozen: bool = field(metadata=wire("df"))
    unit_name: str | None = field(default=None, metadata=wire("un"))
    asset_name: str | None = field(default=None, metadata=wire("an"))
    url: str | None = field(default=None, metadata=wire("au"))
    metadata_hash: bytes | None = field(
        default=None,
        metadata=wire(
            "am",
            encode=encode_bytes_base64,
            decode=decode_bytes_base64,
        ),
    )
    manager: str | None = field(default=None, metadata=addr("m"))
    reserve: str | None = field(default=None, metadata=addr("r"))
    freeze: str | None = field(default=None, metadata=addr("f"))
    clawback: str | None = field(default=None, metadata=addr("c"))


@dataclass(slots=True)
class LedgerAssetParamsDelta:
    deleted: bool = field(metadata=wire("Deleted"))
    params: LedgerAssetParams | None = field(
        default=None,
        metadata=nested("Params", lambda: LedgerAssetParams),
    )


@dataclass(slots=True)
class LedgerAssetResourceRecord:
    asset_id: int = field(metadata=wire("Aidx"))
    address: str = field(metadata=addr("Addr"))
    params: LedgerAssetParamsDelta = field(metadata=nested("Params", lambda: LedgerAssetParamsDelta))
    holding: LedgerAssetHoldingDelta = field(metadata=nested("Holding", lambda: LedgerAssetHoldingDelta))


@dataclass(slots=True)
class LedgerVotingData:
    vote_id: bytes = field(
        metadata=wire(
            "VoteID",
            encode=encode_bytes_base64,
            decode=decode_bytes_base64,
        ),
    )
    selection_id: bytes = field(
        metadata=wire(
            "SelectionID",
            encode=encode_bytes_base64,
            decode=decode_bytes_base64,
        ),
    )
    state_proof_id: bytes = field(
        metadata=wire(
            "StateProofID",
            encode=encode_bytes_base64,
            decode=decode_bytes_base64,
        ),
    )
    vote_first_valid: int = field(metadata=wire("VoteFirstValid"))
    vote_last_valid: int = field(metadata=wire("VoteLastValid"))
    vote_key_dilution: int = field(metadata=wire("VoteKeyDilution"))


@dataclass(slots=True)
class LedgerAccountBaseData:
    status: int = field(metadata=wire("Status"))
    micro_algos: int = field(metadata=wire("MicroAlgos"))
    rewards_base: int = field(metadata=wire("RewardsBase"))
    rewarded_micro_algos: int = field(metadata=wire("RewardedMicroAlgos"))
    auth_address: str = field(metadata=addr("AuthAddr"))
    incentive_eligible: bool = field(metadata=wire("IncentiveEligible"))
    total_app_schema: LedgerStateSchema = field(metadata=nested("TotalAppSchema", lambda: LedgerStateSchema))
    total_extra_app_pages: int = field(metadata=wire("TotalExtraAppPages"))
    total_app_params: int = field(metadata=wire("TotalAppParams"))
    total_app_local_states: int = field(metadata=wire("TotalAppLocalStates"))
    total_asset_params: int = field(metadata=wire("TotalAssetParams"))
    total_assets: int = field(metadata=wire("TotalAssets"))
    total_boxes: int = field(metadata=wire("TotalBoxes"))
    total_box_bytes: int = field(metadata=wire("TotalBoxBytes"))
    last_proposed: int = field(metadata=wire("LastProposed"))
    last_heartbeat: int = field(metadata=wire("LastHeartbeat"))


@dataclass(slots=True)
class LedgerAccountData:
    account_base_data: LedgerAccountBaseData = field(metadata=flatten(lambda: LedgerAccountBaseData))
    voting_data: LedgerVotingData = field(metadata=flatten(lambda: LedgerVotingData))


@dataclass(slots=True)
class LedgerBalanceRecord:
    address: str = field(metadata=addr("Addr"))
    account_data: LedgerAccountData = field(metadata=flatten(lambda: LedgerAccountData))


@dataclass(slots=True)
class LedgerAccountDeltas:
    accounts: list[LedgerBalanceRecord] = field(
        default_factory=list,
        metadata=wire(
            "Accts",
            encode=encode_model_sequence,
            decode=lambda raw: _decode_sequence(lambda: LedgerBalanceRecord, raw),
        ),
    )
    app_resources: list[LedgerAppResourceRecord] = field(
        default_factory=list,
        metadata=wire(
            "AppResources",
            encode=_encode_optional_sequence,
            decode=lambda raw: _decode_sequence(lambda: LedgerAppResourceRecord, raw),
        ),
    )
    asset_resources: list[LedgerAssetResourceRecord] = field(
        default_factory=list,
        metadata=wire(
            "AssetResources",
            encode=_encode_optional_sequence,
            decode=lambda raw: _decode_sequence(lambda: LedgerAssetResourceRecord, raw),
        ),
    )


@dataclass(slots=True)
class LedgerKvValueDelta:
    data: bytes | None = field(
        default=None,
        metadata=wire(
            "Data",
            encode=encode_bytes_base64,
            decode=decode_bytes_base64,
        ),
    )
    old_data: bytes | None = field(
        default=None,
        metadata=wire(
            "OldData",
            encode=encode_bytes_base64,
            decode=decode_bytes_base64,
        ),
    )


@dataclass(slots=True)
class LedgerIncludedTransactions:
    last_valid: int = field(metadata=wire("LastValid"))
    intra: int = field(metadata=wire("Intra"))


@dataclass(slots=True)
class LedgerModifiedCreatable:
    creatable_type: int = field(metadata=wire("Ctype"))
    created: bool = field(metadata=wire("Created"))
    creator: str = field(metadata=addr("Creator"))
    ndeltas: int = field(metadata=wire("Ndeltas"))


@dataclass(slots=True)
class LedgerAlgoCount:
    money: int = field(metadata=wire("mon"))
    reward_units: int = field(metadata=wire("rwd"))


@dataclass(slots=True)
class LedgerAccountTotals:
    online: LedgerAlgoCount = field(metadata=nested("online", lambda: LedgerAlgoCount))
    offline: LedgerAlgoCount = field(metadata=nested("offline", lambda: LedgerAlgoCount))
    not_participating: LedgerAlgoCount = field(metadata=nested("notpart", lambda: LedgerAlgoCount))
    rewards_level: int = field(metadata=wire("rwdlvl"))


@dataclass(slots=True)
class LedgerStateDelta:
    accounts: LedgerAccountDeltas = field(metadata=nested("Accts", lambda: LedgerAccountDeltas))
    block: Block = field(metadata=nested("Hdr", lambda: Block))
    state_proof_next: int = field(metadata=wire("StateProofNext"))
    prev_timestamp: int = field(metadata=wire("PrevTimestamp"))
    totals: LedgerAccountTotals = field(metadata=nested("Totals", lambda: LedgerAccountTotals))
    kv_mods: dict[bytes, LedgerKvValueDelta] | None = field(
        default=None,
        metadata=wire(
            "KvMods",
            encode=_encode_kv_delta_map,
            decode=_decode_kv_delta_map,
        ),
    )
    txids: dict[bytes, LedgerIncludedTransactions] | None = field(
        default=None,
        metadata=wire(
            "Txids",
            encode=_encode_txid_map,
            decode=_decode_txid_map,
        ),
    )
    txleases: object | None = field(default=None, metadata=wire("Txleases"))
    creatables: dict[int, LedgerModifiedCreatable] | None = field(
        default=None,
        metadata=wire(
            "Creatables",
            encode=_encode_creatables,
            decode=_decode_creatables,
        ),
    )
